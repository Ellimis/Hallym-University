#include <stdio.h> 
#include <stdlib.h> // for abs, malloc function

// 1번
int main() {
	int n = 0, m = 0;

	scanf_s("%d %d", &n, &m);

	// n과 m은 자연수이자 10000 이하의 수이다.
	if ((0 < n && n <= 10000) && (0 < m && m <= 10000))
	{
		// 입력받은 n개에 대한 공간 할당
		int* book_loc = (int*)malloc(sizeof(int) * n);
		int i;

		// 입력받은 n개의 책들에 대한 위치 정보를 받는 반복문
		// 입력 예시 : -37 2 -6 -39 -29 11 -28
		for (i = 0; i < n; i++)
		{
			int temp;

			scanf_s("%d", &temp);

			// 책의 위치는 0이 아니고, 절댓값이 10000이하이다.
			if ((temp != 0) && (abs(temp) <= 10000))
				book_loc[i] = temp;
			else // 재입력
			{
				i--;
				continue;
			}
		}


		// 버블 정렬, 오름차순 정렬
		// -39 -37 -29 -28 -6 2 11
		int temp, j;

		for (i = 0; i < n; i++)
		{
			for (j = 0; j < n - i - 1; j++)
			{
				if (book_loc[j] > book_loc[j + 1])
				{
					temp = book_loc[j];
					book_loc[j] = book_loc[j + 1];
					book_loc[j + 1] = temp;
				}
			}
		}

		// 양수(오른쪽) 부분과 음수(왼쪽) 부분을 나누기 위한 plusLoc 변수
		// 데이터가 모두 양수나 음수로 이루어져있을 경우 plusLoc = 0
		int plusLoc = 0;

		for (i = 0; i < n; i++)
		{
			// 양수로 넘어갈 때 plusLoc 지정
			if (book_loc[i] > 0)
			{
				// plusLoc index : 양수 시작부분
				// plusLoc - 1 index : 음수 시작부분
				plusLoc = i;
				break;
			}
		}

		int index = n - 1;
		int minStep = 0;
		int isChange = 0;

		// 인덱스를 끝에서부터 0번째 인덱스까지 검사
		while (0 <= index)
		{
			// 양수(오른쪽) 부분과 음수(왼쪽) 부분을 생각하여 현재 책이 있는 위치 0 에서부터 그 지점까지 왕복하는 걸음 수를 더해줌
			// -39 -37 -29 -28 -6 2 11
			// 0 + 11*2 + 6*2 + 29*2 + 39*2
			minStep = minStep + 2 * abs(book_loc[index]);
			index -= m;

			// 책의 위치가 모두 양수거나 음수일 경우 넘어간다.
			// 만약 양수 음수로 나뉘게 되는 위의 입력에서 m이 3일 경우,
			// -39 -37 -29 -28 -6 2 11 에서 양수 부분이 끝나면서 다음 index가 -28을 가르키게 되므로
			// 조건문을 통해 음수 부분으로 넘어왔을 때 음수의 처음 시작 부분부터 할 수 있도록 지정
			if ((isChange == 0) && (index < plusLoc))
			{
				// plusLoc = 5, 음수의 데이터 갯수가 홀수
				if ((plusLoc) % 2 != 0)
					index = plusLoc - 1;

				isChange = 1;
			}
		}

		// 책을 모두 제자리에 둔 상태인데 다시 0으로 돌아왔으므로 절대값이 큰 쪽의 걸음 수를 뺌으로써 
		// 모든 책을 제자리에 놔둔 후에 0으로 돌아가지 않고 끝나는 걸로 보이게 하는 조건문
		// -39 -37 -29 -28 -6 2 11
		if (abs(book_loc[0]) > abs(book_loc[n - 1]))
			// 절대값이 왼쪽에 더 큰 것이 있을 때
			minStep -= abs(book_loc[0]);
		else
			// 절대값이 오른쪽에 더 큰 것이 있을 때
			minStep -= book_loc[n - 1];

		// 최소 걸음수 출력
		printf("\n%d", minStep);

		// 공간 할당 해제
		free(book_loc);
	}

	return 0;
}